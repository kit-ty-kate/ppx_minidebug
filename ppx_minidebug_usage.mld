{0 [ppx_minidebug] usage}

[ppx_minidebug] traces selected code if it has type annotations. [ppx_minidebug] offers three ways of instrumenting the code: [%debug_pp] and [%debug_show] based on [deriving.show], and [%debug_sexp] based on the [sexplib]. The syntax extension expects a module [Debug_runtime] in the scope. [minidebug_runtime] offers three ways of logging the traces, as functors generating [Debug_runtime] modules given a file path.

Take a look at {{:https://github.com/dariusf/ppx_debug} [ppx_debug]} which is significantly more powerful!

{1 Usage}

To trace a function, you have to type-annotate the function result. To trace an argument of a traced function, or a [let]-binding, you need to type-annotate it. You can control how much gets logged by adding or removing type annotations.

Tracing only happens in explicitly marked scopes, using the extension points: [%debug_pp], [%debug_this_pp], [%debug_show], [%debug_this_show] (based on printing functionality provided by [deriving.show]), [%debug_sexp], [%debug_this_sexp] (using functionality provided by [sexplib] and [ppx_sexp]). See examples in {{:https://github.com/lukstafi/ppx_minidebug/tree/main/test} the test directory}.

The [%debug_this] variants are intended only for [let]-bindings: [let%debug_this v: t = compute value in body] will trace [v] and the type-annotated bindings and functions inside [compute value], but it will not trace [body].
